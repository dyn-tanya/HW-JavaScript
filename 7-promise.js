//Асинхоронність. Виконуємо дії, час який не відомий. У Сайпрес не сильно переживаємо за синхронність чи асинхронність. JS Promise - результат операції яка ще не завершена, але буде завершена в майбутньому
//Проміси - базове поняття, що допомагає розробникам боротися з асинхронністью
//Приклад - це мережевий запит, з АПІ. Немає способу визначити час відповіді.
//Проміси - забезпечують стандартизований і чистий метод виз-ня задач, які потрібно реалізувати в певній послідовності. 

console.log('Запит даних з серверу ...');

setTimeout(() => { //чекає таймайут, а потім виконує, що йде 1 аргументом
    console.log('Підготовка даних для відповіді з сервера ...');

    const product = {
        name: 'Laptop',
        price: 1000
    }

    setTimeout(() => {
        product.status = 'inStock';
        console.log(product);
    }, 2000)

}, 10000);

//створення проміс (коли більше 3 і більше)
const req = new Promise((resolve, reject) = {}); //сам проміс - окремий об'єкт, всередину передається кол-бек функція, що містить 2 параметра resolve, reject. 
//resolve - якщо функція відпрацювала успішно
//reject - коли помилка
// resolve, reject - функції, які надалі можна передавати в поміс в тіло функції
//Спосіб синхронізації певних дій


const req2 = new Promise((resolve, reject) => {
    console.log('Запит даних з серверу ...');

    setTimeout(() => { //чекає таймайут, а потім виконує, що йде 1 аргументом
        console.log('Підготовка даних для відповіді з сервера ...');

        const product = {
            name: 'Laptop',
            price: 1000
        }

        setTimeout(() => {
            product.status = 'inStock';
            console.log(product);
        }, 2000)

    }, 10000);


});

const req3 = new Promise((resolve, reject) => {
    console.log('Запит даних з серверу ...');

    setTimeout(() => { //чекає таймайут, а потім виконує, що йде 1 аргументом
        console.log('Підготовка даних для відповіді з сервера ...');

        const product = {
            name: 'Laptop',
            price: 1000
        }

        resolve(product); // якщо код віпрацював успішно, то виконається функція product (в якості резолву функція проміс)
        //для того щоб вик-ти функцію то виконуємо функцію зе
        ///Дві дії котрі синхронізувати хочете, зробили проміс і після цього вказали, якщо все ок виконай резолв
        //за допомогою зенів синхронізувати певні дії

    }, 10000);


});

//Якщо проміс зарезолвився успішно викликаємо функцію
// 99% функцій Сайпреса в якості результата повертають проміс, усі дії над елементами повертають проміс

req3.then((product) => { //Якщо  функція виконалась успішно, метод then, який є результатом вик-ня функцій
    setTimeout(() => {
        product.status = 'inStock';
        console.log(product);
    }, 2000)

})


const req4 = new Promise((resolve, reject) => {
    console.log('Запит даних з серверу ...');

    setTimeout(() => { //чекає таймайут, а потім виконує, що йде 1 аргументом
        console.log('Підготовка даних для відповіді з сервера ...');

        const product = {
            name: 'Laptop',
            price: 1000
        }

        resolve(product); //в якості резолву функція проміс

    }, 10000);


});

req4.then((product) => {
    const req5 = new Promise((resolve, reject) => {
        setTimeout(() => {
            product.status = 'inStock';
            resolve(product);
        }, 2000)
    })

    req5.then((product) => {
        console.log(product);
    })

    //Проміси можуть повертати проміс із зена, коли одна асинхронна закінчиться, буде по ланцюжку вик-ся наступна
})

//Код викся по порядку, а результат як вийде. Якщо рез 1 операції викор-ємо в наступних кроках, то воно виконається з помилкою
//Тривалість вик-ня для дій невідома  - для цього потрібні проміси і колбеки

let error = true;
const req9 = new Promise((resolve, reject) => {
    console.log('Запит даних з серверу ...');

    setTimeout(() => { ////чекає таймайут, а потім виконує, що йде 1 аргументом
        console.log('підготовка даних для відповіді сервера ...');

        const product = {
            name: 'Laptop',
            price: 10000
        }

    if(error){ //коли щось пішло не так
        reject(product);
       
        
     }

     resolve(product);  // якщо код відпрацював успішно, запускається резолв
    

    }, 10000)

})

req9.then((product) => {
    return new Promise ( (resolve, reject) => {
        setTimeout(() => { 
            product.status = 'inStock';
            resolve(product);
        }, 2000)
    })
}).then( product => {  //в кожному зені можемо вказувати будь який новий параметр
    product.isModified = true;
    return product;
}).then( product => {
    console.log(product)
}).catch( product => {
    console.log('Error happend')
    console.log(product)
}).finally(() => { //виконається в будь якому випадку
    console.log('Finally')
})

///Всі дії повертають проміс
// then - метод, котрий вик-ся у випадках коли проміс зарезолвився успішно
//Спосіб синхронізувати певні асинхронні дії

//Кол беки - явно вказуємо в якому місці виконати ту чи іншу фукнцію, для 1-2 дій

